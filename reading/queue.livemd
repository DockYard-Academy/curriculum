# Queues

```elixir
Mix.install([
  {:youtube, github: "brooklinjazz/youtube"},
  {:hidden_cell, github: "brooklinjazz/hidden_cell"},
  {:tested_cell, github: "brooklinjazz/tested_cell"},
  {:utils, path: "#{__DIR__}/../utils"}
])
```

## Navigation

[Return Home](../start.livemd)<span style="padding: 0 30px"></span>
[Report An Issue](https://github.com/DockYard-Academy/beta_curriculum/issues/new?assignees=&labels=&template=issue.md&title=)

## Setup

Ensure you type the `ea` keyboard shortcut to evaluate all Elixir cells before starting. Alternatively, you can evaluate the Elixir cells as you read.

## Queues

Queues are an abstract data structure based on the common human
experience of waiting in lines. In human lines, people arrive at
the end of the line and are served from the front of the line.

<!-- livebook:{"break_markdown":true} -->

```mermaid
flowchart
  subgraph Queue
    direction LR
    Last[Last/Newest] --> NextN[NextN] -- ... --> Next[Next] --> First[First/Oldest]
  end
```

<!-- livebook:{"break_markdown":true} -->

In programming we have defined a Queue as:

* The first item in the queue is called the *front* or *first*.
* The *front* of the queue is gotten and removed when we
  *dequeue* the queue.
* The last item in the queue is called the *back* or *last*.
* Items are added to the *back* of the queue when we
  *enqueue* a new item.

```mermaid
flowchart
  subgraph Queue-Actions
    direction LR
    New[NewLast/NewNewest] -- "(enqueue)" --> Last[Last/Newest]
    subgraph Queue
      direction LR
      Last[Last/Newest] --> NextN[NextN] -- ... --> Next[Next] --> First[First/Oldest]
    end
    First[First/Oldest] -- "(dequeue)" --> Out["."]
  end
```

So, you might be wonder: *Great! So what is the syntax for Elixir's
`Queue` data structure?* There is no built-in Queue data strucuture;
and this is why a Queue is called an "abstract data structure": You
must implement the concept yourself.

The most common implementation of a Queue is to base it on a List.

### Your Turn

How would you create a new empty Queue?

```elixir
defmodule Queue do
  def new() do
    :your_code_here
  end
end
```

Continuing, a new Queue should be empty of course!

```elixir
defmodule Queue do
  def new() do
    :your_code_here
  end

  def empty?(queue) do
    :your_code_here
  end
end
```

Continuing, how would you *enqueue* an item -- let's say `:bob` -- to an empty Queue?

```elixir
defmodule Queue do
  def new() do
    :your_code_here
  end

  def empty?(queue) do
    :your_code_here
  end

  def enqueue(queue, item) do
    :your_code_here
  end
end
```

Continuing, it might be nice to know how many items are in the Queue.

```elixir
defmodule Queue do
  def new() do
    :your_code_here
  end

  def empty?(queue) do
    :your_code_here
  end

  def enqueue(queue, item) do
    :your_code_here
  end

  def size(queue) do
    :your_code_here
  end
end
```


Continuing, how would you *dequeue* an item from our non-empty
Queue? The *dequeue*d item's value should be `:bob`. Dont forget
to return the new queue (without `:bob`) also!

```elixir
defmodule Queue do
  def new() do
    :your_code_here
  end

  def empty?(queue) do
    :your_code_here
  end

  def enqueue(queue, item) do
    :your_code_here
  end

  def size(queue) do
    :your_code_here
  end

  def dequeue(queue) do
    :your_code_here
  end
end
```

### Your Turn

Imagine people forming a line, arriving and leaving from it.

Using your Queue module above, create a queue where the following people
arrived in this order:

* Soren
* Ram
* Cindy
* Sam

```mermaid
flowchart
  subgraph Waiting
    direction LR
    Sam[Sam] --> Cindy[Cindy] --> Ram[Ram] --> Soren[Soren]
  end
```

<details style="background-color: lightgreen; padding: 1rem; margin: 1rem 0;">
<summary>Example solution</summary>

```elixir
defmodule Line do
  def arrivals(people) do
    Enum.reduce(people, Queue.new(), fn arrival, queue ->
      Queue.enqueue(queue, arrival)
    end)
  end
end

people = ["Soren", "Ram", "Cindy", "Sam"]
line = Line.arrivals(people)
IO.inspect(line, label: "In line is")
```

</details>

Enter your solution below.

```elixir
defmodule Line do
  def arrivals(people) do
    :your_code_here
  end
end

people = []
line = Line.arrivals(people)
```

Continuing, update your Line so that it can serve some number of people
from the line. Have it serve the first 2 people from the line:

  * Who gets served?
  * Who remains in the line?

<details style="background-color: lightgreen; padding: 1rem; margin: 1rem 0;">
<summary>Example solution</summary>

```elixir
defmodule Line do
  def arrivals(people) do
    Enum.reduce(people, Queue.new(), fn arrival, queue ->
      Queue.enqueue(queue, arrival)
    end)
  end

  def serve(line, number) do
    case number do
      0 -> line
      _ ->
        {first, line} = Queue.dequeue(line)
        IO.inspect(first, label: "Just served")
        serve(line, number-1)
    end
  end
end

line = Line.serve(line, 2)
IO.inspect(line, label: "Remaining in line is")
```

</details>

Enter your solution below.

```elixir
:your_code_here
```

Continuing, remove and display all the remaining people from
the line, until the line is empty. Who was removed and in
what order?

<details style="background-color: lightgreen; padding: 1rem; margin: 1rem 0;">
<summary>Example solution</summary>

```elixir
defmodule Line do
  def arrivals(people) do
    Enum.reduce(people, Queue.new(), fn arrival, queue ->
      Queue.enqueue(queue, arrival)
    end)
  end

  def serve(line, number) do
    case number do
      0 -> line
      :all -> serve(line, Queue.size(line))
      _ ->
        {first, line} = Queue.dequeue(line)
        IO.inspect(first, label: "Just served")
        serve(line, number-1)
    end
  end
end

line = Line.serve(line, :all)
```

</details>

Enter your solution below.

```elixir
:your_code_here
```

## Further Reading

Consider the following resource(s) to deepen your understanding of the topic.

* [Wikipedia: Queue](https://en.wikipedia.org/wiki/Queue_(abstract_data_type))
* [Exercism: Lists](https://exercism.org/tracks/elixir/concepts/lists)
* [Elixir Lang: Lists](https://elixir-lang.org/getting-started/basic-types.html#linked-lists)
* [HexDocs: List](https://hexdocs.pm/elixir/List.html)

## Commit Your Progress

Run the following in your command line from the beta_curriculum folder to track and save your progress in a Git commit.

```
$ git add .
$ git commit -m "finish lists section"
```

## Up Next

| Previous                           | Next                                             |
| ---------------------------------- | -----------------------------------------------: |
| [Tuples](../reading/tuples.livemd) | [Keyword Lists](../reading/keyword_lists.livemd) |
