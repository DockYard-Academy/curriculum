# Control Flow

## Setup

```elixir
Mix.install([
  {:kino, "~> 0.5.1"}
])
```

## Overview

Control flow. What does that mean?

Well, so far you've learned mostly about how to give computers a single set of instructions.
But sometimes, depending on certain conditions, you want to deliver a different set of instructions.

```mermaid
flowchart
  Input --- Condition
  Condition --- 1[Instruction] 
  Condition --- 2[Instruction]
```

The flow of our program through these branches, and how we control it is called **control flow**.
We have a variety of tools to control the flow of our program.

Let's say you're building a rock paper scissors game. 
We'll assume you're familiar with the rules.

* Rock beats Scissors
* Paper beats Rock
* Scissors beats Paper

Player1 will input `"Rock"`, `"Paper"`, or `"Scissors"`. Then player2 will do the same.
then the program will return either `"player1"` or `"player2"` depending on who won.

```mermaid
flowchart LR
  Rock --> Function
  Paper --> Function
  Scissors --> Function
  Function --> Player1
  Function --> Draw
  Function --> Player2
```

The branching arrows represent a different flow
that our program might take. Depending on the input the player
will either win, lose, or draw.

So how would you implement a game like this? Well, you might try to use operators. We'll start by
assuming player2 always chooses rock.

```elixir
defmodule RockPaperScissors do
  def play(player1_choice) do
    (player1_choice === "Rock" && "Draw") ||
      (player1_choice === "Paper" && "Player1") ||
      (player1_choice === "Scissors" && "Player2")
  end
end

RockPaperScissors.play("Scissors")
```

That worked, but what about when we try to accept input from player 2?

```elixir
defmodule RockPaperScissors do
  def play(player1_choice, player2_choice) do
    (player1_choice === "Rock" && player2_choice === "Rock" && "Draw") ||
      (player1_choice === "Rock" && player2_choice === "Paper" && "Player2") ||
      (player1_choice === "Rock" && player2_choice === "Scissors" && "Player1") ||
      (player1_choice === "Paper" && player2_choice === "Rock" && "Player2") ||
      (player1_choice === "Paper" && player2_choice === "Paper" && "Draw") ||
      (player1_choice === "Paper" && player2_choice === "Scissors" && "Player2") ||
      (player1_choice === "Scissors" && player2_choice === "Rock" && "Player2") ||
      (player1_choice === "Scissors" && player2_choice === "Paper" && "Player1") ||
      (player1_choice === "Scissors" && player2_choice === "Scissors" && "Draw")
  end
end

RockPaperScissors.play("Rock", "Rock")
```

Woah. Ok, that's a bit overwhelming and unclear. For example. I've purposely left
a bug in the code above. Can you find it?

### Your Turn

Find the bug in the code above and call the module function with the input that will trigger it.

<details>
<summary>Spoiler</summary>
It's "Paper" and "Rock". player1 should win, but instead player2 wins.
</details>

```elixir

```

### Clear Control Flow

So, control flow is the branching flow of decisions in our program.
In the rock paper scissors game it's the following.

```mermaid
flowchart
  A[Rock] --> 1[Rock] --> a[Draw]
  A[Rock] --> 2[Paper] --> b[Lose]
  A[Rock] --> 3[Scissors]  --> c[Win]
  B[Paper] --> 4[Rock] --> d[Win]
  B[Paper] --> 5[Paper] --> e[Draw]
  B[Paper] --> 6[Scissors]  --> f[Lose]
  C[Scissors] --> 7[Rock] --> g[Lose]
  C[Scissors] --> 8[Paper] --> h[Win]
  C[Scissors] --> 9[Scissors] --> i[Draw]
```

Often the complexity of a program is determined by the number of branching decisions it needs to make.

```mermaid
flowchart
  A[Input] --> B[Decision]
  B --> B1[Decision]
  B --> B2[Decision]
  B --> B3[Decision]
  B1 --> B11[Decision]
  B1 --> B12[Decision]
  B1 --> B13[Decision]
  B2 --> B21[Decision]
  B2 --> B22[Decision]
  B2 --> B23[Decision]
  B3 --> B31[Decision]
  B3 --> B32[Decision]
  B3 --> B33[Decision]
```

While it may seem complicated in the code, rock paper scissors is a relatively simple program compared to
the many real-world programs out there.

To handle this complexity, Elixir provides a number of control flow structures
that make our job easier.

In this lesson, we'll cover:

* Using `if` and `unless` to handle control flow with two paths.
* Using `case` to create many branching flows depending on a single input.
* Using `cond` to create many branching flows depending on many inputs.
* **Pattern matching** with the **match operator**
* Using `with` to check a series of conditions before entering a path.
* using **Multi-clause functions** with **pattern matching**
* Handling errors with the :ok, and :error tuple and **pattern matching**

## If

In the real world, you use **if** all the time.

* If it is rainy then I will stay inside
* If it is sunny then I will go outdoors

`if` means exactly what it says. It checks for some condition, then executes some
action.

In Elixir, we provide if a boolean or a truthy value, and then execute the block of code inside of it.

```elixir
if true do
  "Hello!"
end
```

However, if we pass `if` `nil` or `false`, then it will not execute the code inside.

```elixir
if false do
  "Hello"
end
```

Passing if a literal `true` or `false` value isn't useful. Anytime you do that you know
you've probably made a mistake in your code.

<details>
<summary>Why?</summary>
Because, you already you wanted to execute the code inside the `if` or not, so you should omit
the `if` statement.
</details>

Instead, it's more useful to check if some condition is true. For example, here's 
a little program that checks the current hour of the day and displays either `"Good morning!"`
or `"Good afternoon!"`.

the `DateTime.utc_now/0` function creates a `DateTime` struct with the current time.

```elixir
time = DateTime.utc_now()

if time.hour < 12 do
  "Good morning!"
end

if time.hour >= 12 do
  "Good Afternooon!"
end
```

We can also use `else` with if to create two branching paths. 
The code inside of the `else` will execute if the condition in the `if` statement is `false` or `nil`.

Let's improve the code above by using `else`.

```elixir
time = DateTime.utc_now()

if time.hour >= 12 do
  "Good Afternoon!"
else
  "Good Morning!"
end
```

If statements are really good at spliting the control flow in two, but they aren't very good
at splitting it further.

In some programming languages there is an `else if` construct which allows you to create many
conditions. However Elixir relies on other constructs which you will learn about further on in this
lesson.

It's usually unclear to nest if statements and a sign that you can improve your code.

```elixir
condition1 = true
condition2 = true

if condition1 do
  if condition2 do
    {true, true}
  end
end
```

Instead, you can often group conditions together, or rely on a different construct than `if`.

```elixir
if condition1 and condition2 do
  {true, true}
end
```

### Your Turn

Let's create a thermometer program. This thermometer program will take a temperature in and return
`"hot"` or `"cold"`.

To avoid debate and confusion over Celsius and Fahrenheit. Any number greater than or equal 
to `20` will be hot.

Enter your answer in the Elixir cell below.

```elixir

```

## Unless

`unless` is `if` in reverse. It's helpful for times when you want to always do something unless
some condition is true.

For example,

* unless it rains on sunday lets go to the park
* unless it is the weekend you work
* unless it's high tide, lets go to the beach.

```elixir
unless false do
  "Hello!"
end
```

```elixir
unless true do
  "Hello!"
end
```

```elixir
is_raining = false

unless is_raining do
  "Let's go to the beach!"
end
```

You can also use `else` with unless but it's not always the most clear to read and should probably
be an `if` instead.

```elixir
condition = true

unless condition do
else
  "Will I print?"
end
```

### Your Turn

In the Elixir cell below

* Create an variable named `tired` which is `true` or `false`.
* Create an `unless` statement. which returns `"awake"` unless `tired`

```elixir

```

## Case

Case is often sometimes `switch case` in other languages.
It's a control flow structure that allows you to define a series of cases.

For example

* case 1: It's sunny so wear a t-shirt.
* case 2: It's rainy so wear a rain jacket.
* case 3: It's cold so wear a sweater.
* case 4: It's snowing so wear a thick coat.

```mermaid
flowchart
  case --> 1
  case --> 2
  case --> 3
  case --> 4
  1[sunny] --> A[wear a t-shirt]
  2[rainy] --> B[wear a rain jacket]
  3[cold] --> C[wear a sweater]
  4[snowing] --> D[wear a thick coat]
```

To use a case statement start with the `case` keyword

<!-- livebook:{"force_markdown":true} -->

```elixir
case
```

Then enter a value that will trigger the many cases. We'll use "sunny" from above.

<!-- livebook:{"force_markdown":true} -->

```elixir
case "sunny"
```

Now write the `do` keyword to start defining the series of potential cases.

<!-- livebook:{"force_markdown":true} -->

```elixir
case "sunny" do

```

Start defining the "sunny" case

<!-- livebook:{"force_markdown":true} -->

```elixir
case "sunny" do
  "sunny"
```

Separate the "sunny" case and what will happen with the value is "sunny" using `->`

<!-- livebook:{"force_markdown":true} -->

```elixir
case "sunny" do
  "sunny" -> 
```

Enter what will happen when it's the `"sunny"` case. `"wear a t-shirt"`.

<!-- livebook:{"force_markdown":true} -->

```elixir
case "sunny" do
  "sunny" -> "wear a t-shirt"
```

`end` the case statement.

<!-- livebook:{"force_markdown":true} -->

```elixir
case "sunny" do
  "sunny" -> "wear a t-shirt"
end
```

<!-- livebook:{"break_markdown":true} -->

That gives us the following case statement.

```elixir
case "sunny" do
  "sunny" -> "wear a t-shirt"
end
```

You can create more cases as well. Let's fill in the rest of the examples from above. It's
still going to return the `"sunny"` case though.

```elixir
case "sunny" do
  "sunny" -> "wear a t-shirt"
  "rainy" -> "wear a rain jacket"
  "cold" -> "wear a sweater"
  "snowy" -> "wear a thick coat"
end
```

### Your Turn

If the value between `case` and `do` changes, it will hit a different case.
try changing the `weather` variable by binding it to `"rainy"` and re-evaluate the 
Elixir cell. Try that again with `"cold"`, and `"snowy"`

```elixir
weather = "sunny"

case weather do
  "sunny" -> "wear a t-shirt"
  "rainy" -> "wear a rain jacket"
  "cold" -> "wear a sweater"
  "snowy" -> "wear a thick coat"
end
```

### Case Visualization

Under the hood, Elixir is checking the value given to the case statement, and then checking
if it matches any of the cases. For case that matches the given value, it executes that case.
Like so:

````elixir
# TODO - Hide this code

sequence = [
  "
```elixir
# We create a case statement.
case \"snowy\" do
  \"sunny\" -> \"wear a t-shirt\"
  \"rainy\" -> \"wear a rain jacket\"
  \"cold\" -> \"wear a sweater\"
  \"snowy\" -> \"wear a thick coat\"
end
```
  ",
  "
```elixir
# Check if snowy equals sunny.
case \"snowy\" do
  \"snowy\" === \"sunny\" -> \"wear a t-shirt\"
  \"rainy\" -> \"wear a rain jacket\"
  \"cold\" -> \"wear a sweater\"
  \"snowy\" -> \"wear a thick coat\"
end
```
  ",
  "
```elixir
# It's false, so check if snowy equals rainy.
case \"snowy\" do
  false -> \"wear a t-shirt\"
  \"snowy\" === \"rainy\" -> \"wear a rain jacket\"
  \"cold\" -> \"wear a sweater\"
  \"snowy\" -> \"wear a thick coat\"
end
```
  ",
  "
```elixir
# It's false, so check if snowy equals cold.
case \"snowy\" do
  false -> \"wear a t-shirt\"
  false -> \"wear a rain jacket\"
  \"snowy\" === \"cold\" -> \"wear a sweater\"
  \"snowy\" -> \"wear a thick coat\"
end
```
  ",
  "
```elixir
# It's false, so check if snowy equals snowy.
case \"snowy\" do
  false -> \"wear a t-shirt\"
  false -> \"wear a rain jacket\"
  false -> \"wear a sweater\"
  \"snowy\" === \"snowy\" -> \"wear a thick coat\"
end
```
  ",
  "
```elixir
# snowy equals snowy.
case \"snowy\" do
  false -> \"wear a t-shirt\"
  false -> \"wear a rain jacket\"
  false -> \"wear a sweater\"
  true -> \"wear a thick coat\"
end
```
  ",
  "
```elixir
# wear a thick coat.




          \"wear a thick coat\"
 
```
  "
]

Kino.animate(2000, 0, fn i ->
  md = Enum.at(sequence, i) |> Kino.Markdown.new()
  {:cont, md, rem(i + 1, length(sequence))}
end)
````

Now, you may notice that if you give the `case` statement a value that doesn't match any case, 
the program crashes with a **CaseClauseError** error.

```elixir
case "no match" do
  "sunnny" -> "wear a t-shirt"
end
```

To provide a default case for the `case` statement, you use an underscore `_`.

```elixir
case "no match" do
  "sunnny" -> "wear a t-shirt"
  _ -> "wear clothing"
end
```

## Cond

`cond` stands for **condition**. It allows you to have many different conditions and branches.

It's unlike case in that instead of checking a single value, it can compare many, and check
for more complex conditions.

For example:

* condition 1: the plant wilting and it's dark -> use a UV light
* condition 2: the plant is wilting and it's sunny -> put the plant in sunlight
* condition 3: It's been 2 weeks since you watered the plant -> water the plant
* condition 4: the plant is dead -> get a new plant

```mermaid
flowchart
  cond --> 1
  cond --> 2
  cond --> 3
  cond --> 4
  1[the plant wilting and it's dark] --> A[use a UV light]
  2[the plant is wilting and it's sunny] --> B[ put the plant in sunlight]
  3[It's been 2 weeks since you watered the plant] --> C[water the plant]
  4[the plant is dead] --> D[get a new plant]
```

Notice that instead of cases based on a single value, we have conditions based on mutliple values
such as the state of the plant, time, and weather.

The syntax for `cond` looks faily similar to case, except there's no value. Instead you give
`cond` a boolean on the left of the `->`.

```elixir
cond do
  true -> "good morning!"
end
```

`true` is the default condition in `cond`. You can use operators on the left-hand side
of the `->` and whichever condition returns `true` first will execute.

Let's convert the example above for plants into code.

```elixir
daylight = true
days_since_watered = 14
plant = "wilting"

cond do
  plant === "wilting" && !daylight -> "use a UV light"
  plant === "wilting" && daylight -> "put the plant in sunlight"
  days_since_watered >= 14 -> "water the plant"
  plant === "dead" -> "get a new plant"
end
```

`cond` will execute the instructions for the first condition that returns true. You often have to
be careful of order. For example, there's a bug in the above condition.

Right now, if it's been 14 days since we watered the plant, we'll always water it. But if the
plant is dead that doesn't really make sense. Instead, we should move the `plant === "dead"` check
to be the highest in priority.

```elixir
daylight = true
days_since_watered = 14
plant = "dead"

cond do
  plant === "dead" -> "get a new plant"
  plant === "wilting" && !daylight -> "use a UV light"
  plant === "wilting" && daylight -> "put the plant in sunlight"
  days_since_watered >= 14 -> "water the plant"
end
```

Let's follow the flow of execution to try to make this more clear.

````elixir
# TODO - Hide Code

sequence = [
  "
Check if plant is dead.
```elixir
daylight = true
days_since_watered = 14
plant = \"healthy\"

cond do
  plant === \"dead\" -> \"get a new plant\"
  plant === \"wilting\" && !daylight -> \"use a UV light\"
  plant === \"wilting\" && daylight -> \"put the plant in sunlight\"
  days_since_watered >= 14 -> \"water the plant\"
end
```
 ",
  "
`false`, so check if plant is wilting and it's dark.
```elixir
daylight = true
days_since_watered = 14
plant = \"healthy\"

cond do
  false -> \"get a new plant\"
  plant === \"wilting\" && !daylight -> \"use a UV light\"
  plant === \"wilting\" && daylight -> \"put the plant in sunlight\"
  days_since_watered >= 14 -> \"water the plant\"
end
```
 ",
  "
`false`, so check if plant is wilting and it's sunny.
```elixir
daylight = true
days_since_watered = 14
plant = \"healthy\"

cond do
  false -> \"get a new plant\"
  false -> \"use a UV light\"
  plant === \"wilting\" && daylight -> \"put the plant in sunlight\"
  days_since_watered >= 14 -> \"water the plant\"
end
```
 ",
  "
`false`, so check if days_since_watered is >= 14.
```elixir
daylight = true
days_since_watered = 14
plant = \"healthy\"

cond do
  false -> \"get a new plant\"
  false -> \"use a UV light\"
  false -> \"put the plant in sunlight\"
  days_since_watered >= 14 -> \"water the plant\"
end
```
 ",
  "
`true`! days_since_watered is >= 14.
```elixir
daylight = true
days_since_watered = 14
plant = \"healthy\"

cond do
  false -> \"get a new plant\"
  false -> \"use a UV light\"
  false -> \"put the plant in sunlight\"
  true -> \"water the plant\"
end
```
 ",
  "
Water the plant.
```elixir








          \"water the plant\"
 
```
 "
]

Kino.animate(2000, 0, fn i ->
  md = Enum.at(sequence, i) |> Kino.Markdown.new()
  {:cont, md, rem(i + 1, length(sequence))}
end)
````

### Your Turn

In the Elixir cell below:

* Create a variable called `grade` which will be a number grade from 1 to 100.
* Create a condition that returns `"A"`, `"B"`, `"C"`, or `"D"` depending on the value of `grade`.

The conditions for `grade` should be:

* 85-100 is an A
* 70-84 is a B
* 55-59 is a C
* 1-54 is a D

```elixir

```

## Pattern Matching

In many other programming languages, the match operator `=` is called an assignment operator.

That makes sense, because so far you've only seen the `=` used to bind values to variables.
However Elixir actually uses **Pattern Matching** and binding instead of assignment.

What is pattern matching? Well rather than simply assigning values to variables, Elixir allows
you to bind variables on the left-hand side of the `=`. So long as it matches the same shape of the
right hand side of the `=`.

What does that mean? Well, we already know we can use `=` to bind the right hand side value to a variable.

```elixir
my_tuple = {1, 2, 3}
```

But did you know that you can also pattern match like this?

```elixir
{one, two, three} = {1, 2, 3}

two
```

You can create an expression on the left-hand side, and so long as it matches the shape
of the data on the right-hand side, you can extract and **match** on internal values.
Here's the same concept with a list

```elixir
[hero, secret_identity] = ["Spider Man", "Peter Parker"]

hero
```

This binds a new variable. If you aren't concerned about a value then you can use underscore `_`
to avoid binding it to a named variable.

```elixir
[_, secret_identity] = ["Spider Man", "Peter Parker"]

secret_identity
```

However, if the left hand side doesn't match the right hand side, then the code will crash with 
a **MatchError**.

```elixir
[name] = ["Spider Man", "Peter Parker"]
```

You can pattern match with any kind of data. So long as the left side matches the right side.

### Your Turn

Replace the variable with a **pattern match** expression to bind every internal value to a new
variable. The first exercise is filled out as an example. Choose any variable name.

```elixir
%{spiderman: identity1} = %{spiderman: "Peter Parker"}
```

```elixir
variable = ["A"]
```

```elixir
variable = {"A", "B"}
```

```elixir
variable = [hello: "world"]
```

## Pattern Matching with Case

Previously, we talked about how the case statement checks for equality.

```elixir
case "same" do
  "same" -> "this will return"
end
```

We're also able to use pattern matching for case statements. The first valid match will execute,
and you can use the variables you assign in the instruction.

```elixir
case [1, 2] do
  [] -> nil
  [one] -> one
  [one, two] -> one + two
end
```

### Your turn

Trigger the `"A"`, `"B"`, `"C"`, and `"D"` cases by changing `my_variable`.

```elixir
my_variable = []

case my_variable do
  [] -> nil
  [1, 2, 3] -> "A"
  %{one: _} -> "B"
  {1, 2, 3, %{hello: "world"}} -> "C"
  10 -> "D"
end
```

## Pattern Matching Multi-Clause Functions

You've already learned about using multi-clause functions with different arity's or different guards.
You can also create multi-clause functions with pattern matching.

```elixir
defmodule Greeter do
  def greet([name1, name2]) do
    "Hello, #{name1} and #{name2}"
  end

  def greet(%{name: name, identity: identity}) do
    "Hi #{identity} err..I mean #{name}"
  end

  def greet(name) do
    "Hello, #{name}"
  end
end
```

```elixir
Greeter.greet("Peter")
```

```elixir
Greeter.greet(["Peter", "Bruce"])
```

```elixir
Greeter.greet(%{name: "Batman", identity: "Bruce Wayne"})
```

## With

`with` is often used together with pattern matching to create "happy path" code.
It's useful whenever you have a series of cases or values that rely on eachother.

You can use with to create check some pre-conditions before executing instructions.

```mermaid
flowchart LR
  with --> 1
  1 --> 2
  2 --> 3
  3 --> 4
  1[pre-condition]
  2[pre-condition]
  3[pre-condition]
  4[instruction]
```

If any of the preconditions fail, the with statement will stop and return the value 
of the failed pre-condition.

```mermaid
flowchart LR
  1[pre-condition]
  2[pre-condition]
  3[pre-condition]
  4[instruction]
  with --> 1
  1 --> 2
  2 --> 3
  3 --> 4
  1 --> 5[failed pre-condition]
  2 --> 5
  3 --> 5
```

Alternatively, you can use `else` to handle the result of a failed precondition.

```mermaid
flowchart LR
  1[pre-condition]
  2[pre-condition]
  3[pre-condition]
  4[instruction]
  with --> 1
  1 --> 2
  2 --> 3
  3 --> 4
  1 --> 5[failed pre-condition]
  2 --> 5
  3 --> 5
  5 --> 6[else]
```

<!-- livebook:{"break_markdown":true} -->

Here's a minimal example `with` with a single pre-condition.

```elixir
is_admin = true

with true <- is_admin do
  "delete user"
end
```

The `with` statement checks is_admin. if `true`, it returns `"delete_user"`.
if any other value, it returns the value of is_admin.

```mermaid
flowchart LR
  with --> is_admin --> 3[delete user]
  is_admin --> 4[is_admin]
```

<!-- livebook:{"break_markdown":true} -->

`with` uses pattern maching to check if the left side of the `<-` matches the right side.
The example above is probably better served using a simple `if` statement, so let's make the example
more realistic and store `is_admin` in a boolean on a user map.

```elixir
user = %{is_admin: true}

with true <- user do
  "delete user"
end
```

Because `%{is_admin: true}` does not match `true`, the with statement returns `%{is_admin: true}`.
Let's correct that.

```elixir
user = %{is_admin: true}

with %{is_admin: true} <- user do
  "delete user"
end
```

Great! That's working. But this is still probably better handled by an `if` or `case` statement.

```elixir
user = %{is_admin: true}

if user === %{is_admin: true} do
  "delete user"
end
```

With is specifically really good for checking a series of pre-conditions.
Let's change our example to sending an email. To send an email we need to ensure:

* the sending user is an admin
* the recieving user has an email
* the email has a title and a body

We also need the `name` of the sender and reciever, and their emails.
If we were to use `case`, here's what that might look like. It's an unclear mess!

```elixir
sending_user = %{name: "Batman", email: "notbrucewayne@bat.net", is_admin: true}
recieving_user = %{name: "Robin", email: "boywonder@bat.net"}
email = %{title: "ROBIN!", body: "WE'RE OUT OF BAT SNACKS!"}

case sending_user do
  %{is_admin: true, name: sender_name, email: sender_email} ->
    case recieving_user do
      %{name: reciever_name, email: reciever_email} ->
        case email do
          %{title: title, body: body} ->
            "from #{sender_name}:#{sender_email} to #{reciever_name}:#{reciever_email} #{title}, #{body}"
        end
    end
end
```

Here's the same code rewritten using `with`. There's still some natural complexity, but it's 
a fair bit more clear.

```elixir
sending_user = %{name: "Batman", email: "notbrucewayne@bat.net", is_admin: true}
recieving_user = %{name: "Robin", email: "boywonder@bat.net"}
email = %{title: "ROBIN!", body: "WE'RE OUT OF BAT SNACKS!"}

with %{is_admin: true, name: sender_name, email: sender_email} <- sending_user,
     %{name: reciever_name, email: reciever_email} <- recieving_user,
     %{title: title, body: body} <- email do
  "from #{sender_name}:#{sender_email} to #{reciever_name}:#{reciever_email} #{title}, #{body}"
end
```

Right now, if a value doesn't match the precondition, it returns the value. for example,
if the sender is `nil` we return `nil`

```elixir
sending_user = nil
recieving_user = %{name: "Robin", email: "boywonder@bat.net"}
email = %{title: "ROBIN!", body: "WE'RE OUT OF BAT SNACKS!"}

with %{is_admin: true, name: sender_name, email: sender_email} <- sending_user,
     %{name: reciever_name, email: reciever_email} <- recieving_user,
     %{title: title, body: body} <- email do
  "from #{sender_name}:#{sender_email} to #{reciever_name}:#{reciever_email} #{title}, #{body}"
end
```

Sometimes it's useful to simply return the value, other times it's useful to handle the error. 
When we want to handle the error you can use `else`. The else block works like a `case`
statement here were we match on the return value of the pre-condition.

```elixir
sending_user = "batman"
recieving_user = %{name: "Robin", email: "boywonder@bat.net"}
email = %{title: "ROBIN!", body: "WE'RE OUT OF BAT SNACKS!"}

with %{is_admin: true, name: sender_name, email: sender_email} <- sending_user,
     %{name: reciever_name, email: reciever_email} <- recieving_user,
     %{title: title, body: body} <- email do
  "from #{sender_name}:#{sender_email} to #{reciever_name}:#{reciever_email} #{title}, #{body}"
else
  error -> "Email not sent because #{error} did not match expected format"
end
```

Much like a `case` statement, you can match on multiple cases to handle different errors.

```elixir
sending_user = %{name: "Joker", email: "joker@jokesonyou.haha"}
recieving_user = %{name: "Robin", email: "boywonder@bat.net"}
email = %{title: "ROBIN!", body: "WE'RE OUT OF BAT SNACKS!"}

with %{is_admin: true, name: sender_name, email: sender_email} <- sending_user,
     %{name: reciever_name, email: reciever_email} <- recieving_user,
     %{title: title, body: body} <- email do
  "from #{sender_name}:#{sender_email} to #{reciever_name}:#{reciever_email} #{title}, #{body}"
else
  %{name: "Joker"} -> "Get out of here Joker!"
  error -> "Email not sent because #{error} did not match expected format"
end
```

### Your turn

In the Elixir cell below

* create a variable scores that is a list `[5, 10, 20]`
* create a with statement that checks that `scores` has 3 elements and through pattern matching
  binds each to a variable.
* in the body of the with statement, add each number together.

```elixir

```

## Expected Errors

Now that you understand control flow and pattern matching, you're ready to tackle error handling.

Computers are nearly perfect. However, humans are not. Errors and bugs are part of life as
a programmer.

Sometimes we can anticipate potential errors. 
For example, what happens when you try to create a Date with an invalid month?

```elixir
Date.new(1998, 122, 21)
```

The module function returns an error tuple `{:error, :invalid_date}`.

For the errors that we expect, Elixir developers established a pattern of using
`:error` and `:ok` tuples.

```elixir
Date.new(1998, 12, 21)
```

Functions that anticipate errors return either
 `{:ok, data}` or `{:error, reason}`

<!-- livebook:{"break_markdown":true} -->

```mermaid
flowchart
  Function --> OK
  Function --> Error
  Error["{error: reason}"]
  OK["{ok: data}"]
```

<!-- livebook:{"break_markdown":true} -->

This allows us to call these functions, and then use pattern matching to handle the `:ok` or `:error`
case.

<!-- livebook:{"break_markdown":true} -->

```mermaid
flowchart
  Caller --- Function
  Caller --> A[ok instructions]
  Caller --> B[error instructions]
  Function --> Output
  Output --- ERROR["{:error, reason}"]
  Output --- OK["{:ok, data}"]
```

<!-- livebook:{"break_markdown":true} -->

The `Date` module expects that we'll sometimes call it with mismatched integers and it handles that
error specifically.

<!-- livebook:{"break_markdown":true} -->

This enables predictable error handling. We can use `case` to match on the `:error` and `:ok` tuples,
then handle them however is appropriate.

```elixir
case Date.new(1998, 12, 21) do
  {:ok, date} -> date
  {:error, reason} -> reason
end
```

### Your Turn

In the Elixir cell below, trigger the `:error` case by changing `Date.new(1998, 12, 21)` to an invalid
date.

```elixir
case Date.new(1998, 12, 21) do
  {:ok, value} -> value
  {:error, reason} -> reason
end
```

### Your Turn

Create a function `convert_to_12_hour`
which takes in an integer from 1 to 24. It will then return the equivalent time
on a 12 hour clock.

* 1 would become `{:ok, "1am"}`
* 14 would become `{:ok, "2pm"}`
* If the value given is less than 1 return `{:error, :time_too_low}`.
* If the value given is greater than 24 return `{:error, :time_too_high}`

## Unexpected Errors

While we can do our best to predict errors, it's truly impossible to predict them all. Some
errors are not within our control, such as the malfunction of physical hardware, some errors
result out of unexpected complexity and behavior.

Some errors result because of external systems, or malformed data, and some errors are because
we spelled **accelleration** with one **l** instead of two. ü§¶‚Äç‚ôÇÔ∏è

Whatever the reason, unpredictable errors happen. Infact, 
Elixir has a philosophy of "Let it crash" which you'll learn more about in future lessons.

There are two main categories of errors. The first is a [RuntimeError](https://hexdocs.pm/elixir/1.13.2/RuntimeError.html).
A runtime error occurs while the program is running. That's why it's called a runtime error.

The other is a [CompileError](https://hexdocs.pm/elixir/1.13.2/CompileError.html)
. A compile error occurs during compile time. 
What is compile time? Compile time when the Elixir source code that you've written gets converted
into binary machine code instructions for the computer.

Elixir is a **compiled** language, so it's instructions get compiled into binary machine code before being
run. Alternatively, some languages are **interpreted**. Interpreted languages get converted into computer instruction as
they run rather than upfront.

Whenever you encounter an error, Elixir attempts to provide information about what
happened by raising an error.

What does **raise** an error mean? You may have noticed Elixir provides a variety of errors that help you understand what
went wrong in your program. Whenever Elixir encounters an error, it stops the current execution and displays an error.

You can manually raise a **RuntimeError** error with the `raise` keyword.

```elixir
raise "Oh no!"
```

You can also trigger a **CompileError** by writing some invalid Elixir syntax. Because Elixir
is compiled, it's able to pre-determine that the code is invalid before running it.

```elixir
you(cannot(just(write(anything))))
```

You've already been introduced to several other kinds of errors. It's not important
that you remember all of them, but you should try to understand what they mean when you see them.

* **FunctionClauseError**: a function is called with input that doesn't match any clause. i.e `Date.new("", "", "")`
* **ArithmeticError**: when you misuse an arithmetic operator i.e. `1 + ""`
* **TokenMissingError**: when you don't complete an expression i.e. `1 +`

These are all runtime errors that occur under specific conditions.
They help you determine the cause of your error better than a generic **RuntimeError**.

<!-- livebook:{"break_markdown":true} -->

```mermaid
flowchart LR
RuntimeError --> FunctionClauseError
RuntimeError --> ArithmeticError
RuntimeError --> TokenMissingError
```

<!-- livebook:{"break_markdown":true} -->

### Try/Rescue

When executing code that could result in an error, you case use `try` and `rescue` to prevent it from crashing
the entire program's execution. The code in the `try` block will run, and if it results in an error,
then the `rescue` block will run. the `rescue` block works like a `case` statement where you can
pattern match on the error from the `try` block.

```elixir
try do
  raise "oh no!"
rescue
  _ -> "that's better"
end
```

In the above example we pattern match using the default case with underscore `_`.
You could instead match on the specific error **RuntimeError**

```elixir
try do
  raise "oh no!"
rescue
  RuntimeError -> "that's better"
end
```

Infact, you have the ability to decide which type of error to `raise`.

```elixir
try do
  raise ArithmeticError, "Math can be hard sometimes"
rescue
  ArithmeticError -> "Fortunately you have support!"
end
```

It's convention in Elixir to use bang `!` in the name of a function that expects to raise an error.
For example, there's an alternative to `Date.new/4` called `Date.new!/4`. Instead of returning an
`:ok` or `:error` tuple it either returns a date, or raises an error.

```elixir
Date.new!(1982, 06, 29)
```

```elixir
Date.new!(11982, 06, 29)
```

### Your Turn

<!-- livebook:{"break_markdown":true} -->

In the Elixir cell below, `raise` a **TokenMissingError**

```elixir

```

In the Elixir cell below

* Create a `try`/`rescue` block.
* Cause a **SyntaxError** in the try block.
* Handle the **SyntaxError** in the rescue block and return `"phew!"` .

```elixir

```
